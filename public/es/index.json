[{"authors":["carlos-vecina"],"categories":null,"content":"Carlos Vecina es un científico de datos con experienca en la aplicación del Machine Learning y de la Inteligencia Artificial con el objetivo de aportar gran valor a negocio en áreas como el CRM, el Marketing y en la compra-venta dentro del mercado eléctrico.\n","date":1564185600,"expirydate":-62135596800,"kind":"taxonomy","lang":"es","lastmod":1569354975,"objectID":"7f2ce30e6e7155580a08c73da392044a","permalink":"/es/authors/carlos-vecina/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/es/authors/carlos-vecina/","section":"authors","summary":"Carlos Vecina es un científico de datos con experienca en la aplicación del Machine Learning y de la Inteligencia Artificial con el objetivo de aportar gran valor a negocio en áreas como el CRM, el Marketing y en la compra-venta dentro del mercado eléctrico.","tags":null,"title":"Carlos Vecina","type":"authors"},{"authors":["pablo-canovas"],"categories":null,"content":"Pablo Cánovas es un científico de datos con experiencia desarrollando y productivizando modelos de Machine Learning aplicados al mercado energético europeo.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"es","lastmod":-62135596800,"objectID":"78b4973aee7e471f2427600fe9f47d84","permalink":"/es/authors/pablo-canovas/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/es/authors/pablo-canovas/","section":"authors","summary":"Pablo Cánovas es un científico de datos con experiencia desarrollando y productivizando modelos de Machine Learning aplicados al mercado energético europeo.","tags":null,"title":"Pablo Cánovas","type":"authors"},{"authors":["Carlos Vecina"],"categories":["Post","R"],"content":"\rEn 7 minutos, seremos capaces de convertir nuestras gráficas generadas con ggplot en espectaculares plots en 3D, ¡y ademas interactivos!\rPodrás embebernos en HTML/Rmarkdown, o incluso mejor, podras exportarlo como mp4 en una animacion rotatoria para sacarle todo el jugo a tus datos!\nComo caso de uso, vamos a visualizar la edad media de los municipios españoles cruzando datos del padrón con los datos GIS, para posteriormente visualizarlos en 3 dimensiones.\n\n1. Introducción\r\nEn las últimas semanas, un ‘nuevo’ paquete de R ha centrado el interés de cierta parte de la comunidad. Decimos ‘nuevo’ porque se ha incorporado recientemente al CRAN, aunque realmente el primer commit realizado por su autor su repo de Github data de hace más de un año. Su nombre es rayshader y en palabras de su propio creador:\n\n\r“rayshader uses elevation data in a base R matrix and a combination of raytracing, spherical texture mapping, overlays, and ambient occlusion to generate beautiful topographic 2D and 3D maps”\n\r\nBajo mi punto de vista, Tyler Morgan-Wall (el autor del paquete) dio con la tecla cuando incorporó al paquete dos nuevas funciones, plot_gg() y render_movie(). La primera de ellas nos permite convertir con 2 líneas de código nuestra visualización en ggplot a una figura 3D de una manera realmente facil y eficiente. La segunda de ellas renderiza esta figura y la anima, poniendo al alcance del usuario diversos parámetros para controlar el zoom, los fps, ángulo, inclinación…\n\n\nLas nuevas funcionalidades y planteamiento del experimento\rLa única condicion que debe cunplir tu gg-visualización es tener como aesthetic color o fill, y en algunos casos también puedes jugar con el size\nEn demasiadas ocasiones, la visualización de datos en 3D no es la mejor opción a elegir, tal y como hablaremos un un futuro post. Por este motivo, he intentado traer un ejemplo donde el uso de la tercera dimensión aporte valor al análisis.\nEste ejemplo práctico consistirá, como ya hemos avanzado, en la visualización en el mapa de España la edad media en cada municipio. ¿Chulo? Para ello necesitaremos:\n\rLos datos del censo sobre las estadísticas de la población (en este caso la edad media) por cada municipio. Estos datos los obtenemos de la web del INE.\n\rLos datos GIS con las coordenadas de cada uno de los municipios que componen España.\n\r\rUna vez que tengamos estas dos fuentes de datos combinados, los visualizaremos y posteriormente exploraremos su renderización en un clip 3D con la figura rotando tal y como se ve en la imagen que encabeza este post.\n¡Vayamos paso por paso!\n\n\r\r2. CdU: Visualizando la edad media de cada municipio en España\rUna vez hemos establecido el objetivo principal y las diferentes fuentes de los datos, podemos proceder a la descarga y tratamiento de los mismos.\n\n2.1- Descargando los datos del censo\rComo digimos, para llevar a cabo nuestro propósito, necesitamos acceder a dos fuentes diferentes de datos. Usaremos el portal de datos abiertos del INE para descargar la edad media en cada municipio español. Después de una búsqueda bastante ardua por su web, encontramos la información que buscábamos. Os dejo este link donde teneis acceso a lo que ellos llaman como estadísticas contínuas\nlink.\nCon el objetivo de no irnos por las ramas, descargaremos directamente el fichero del 2018. Sin embargo, sí que es interesante citar la iniciativa INEbase de facilitar el acceso y la navegación en esta fuente de datos de INE.\nComenzamos cargando (o descargando) los paquetes necesarios para nuestro análisis. En un futuro post o tip compartiremos una función nuestra para la carga (o descarga en caso necesario) múltiple de paquetes en una sola linea.\nlibrary(pxR)\rlibrary(RColorBrewer)\rlibrary(rgeos)\r#install.packages(\u0026quot;rgdal\u0026quot;, repos = \u0026quot;http://cran.us.r-project.org\u0026quot;) reinstall cause gpclib dependencie https://stackoverflow.com/questions/30790036/error-istruegpclibpermitstatus-is-not-true\rlibrary(rgdal)\rlibrary(rayshader)\rlibrary(knitr)\rlibrary(magrittr)\rlibrary(tidyverse)\ras.numeric.factor \u0026lt;- function(x) { # Custom function to convert fctr to num factor value\rreturn(suppressWarnings(as.numeric(levels(x))[x]))\r}\rif(!dir.exists(\u0026quot;data\u0026quot;)) dir.create(\u0026quot;data\u0026quot;) # Create the download directory\r\nDescargando el fichero del INE 2018:\nutils::download.file(url = \u0026quot;http://www.ine.es/pcaxisdl/t20/e245/p05/a2018/l0/00000006.px\u0026quot;,\rdestfile = \u0026quot;data/census_2018.px\u0026quot;)\r\ntbl_census_2018 \u0026lt;- read.px(\u0026quot;data/census_2018.px\u0026quot;) %\u0026gt;% # Load \u0026amp; format\ras_tibble()\rParseamos los datos con el objetivo de conseguir un dataframe que consista en name, postal_code, average_age\ntbl_census_2018 %\u0026lt;\u0026gt;% set_names(c(\u0026quot;age\u0026quot;, \u0026quot;city\u0026quot;, \u0026quot;sex\u0026quot;, \u0026quot;population\u0026quot;)) %\u0026gt;% # Cambiamos los nombre\rna.omit() %\u0026gt;% # Na rmv\rfilter((city!=\u0026quot;Total\u0026quot;)\u0026amp;(age!=\u0026quot;Total\u0026quot;)\u0026amp;(sex==\u0026quot;Ambos sexos\u0026quot;)) %\u0026gt;% # Duplicate info rmv\rseparate(city, c(\u0026#39;postal_code\u0026#39;, \u0026#39;city_name\u0026#39;), sep=\u0026quot;-\u0026quot;) %\u0026gt;% # Sep City column\rmutate(age = as.numeric.factor(age)) %\u0026gt;% # Conv to numeric\rgroup_by(city_name, postal_code) %\u0026gt;% # Group to operate\rsummarise(avg_age = sum(population*age,na.rm = T)/sum(population,na.rm=T)) %\u0026gt;% # Avg age\rselect(city_name, postal_code, avg_age) # Discard columns\rkable( # Just Rmarkdown format\rtbl_census_2018 %\u0026gt;% head(2)\r)\r\r\rcity_name\rpostal_code\ravg_age\r\r\r\rAbabuj\r44001\r52.40789\r\rAbades\r40001\r45.40000\r\r\r\r\n\r2.2- Descargando datos GIS\rLa segunda fuente de datos que vamos a utilizar son los datos geográficos de los municipios españoles, los cuales cruzaremos con los censales anteriormente descargados para pintar la edad media en sus respectivas coordenadas.\nDescargando los daots GIS:\ntemp \u0026lt;- tempfile() # Create the tempfile\ru=\u0026quot;http://www.arcgis.com/sharing/rest/content/items/8e31c4c1a0b348f79058f212d0d807a1/data\u0026quot;\rutils::download.file(url = u, destfile = temp,\rmode=\u0026quot;wb\u0026quot;) # Binary mode for correct download\runzip(temp, exdir = \u0026quot;data/cities_gis\u0026quot;) # Unzip in data/cities_gis\runlink(temp) # Delete temp file\rTratamos estos datos para convertirlos de formato espacial a datos tabulares. Para este caso concreto de 3D, las Islas Canarias podrían deformarnos el gráfico, por lo que decidimos permanecer concentrados en nuestro objetivo didáctico y filtramos estas coordenadas. Por supuesto es posible mantenerlas sin perjudicar el gráfico, alterando sus coordenadas y acercándolas a la península. ¡Esto te queda como tarea para ti!\nPara llevar a cabo este procesado de los datos, usamos la función fortify para no depender de más paquetes. No obstante esta funcion nos lanza un warning sugiriendonos el uso de la función tidy() del paquete broom.\ntlb_cities_gis \u0026lt;- readOGR(dsn = \u0026quot;data/cities_gis/Municipios_ETRS89_30N.shp\u0026quot;,\rverbose=FALSE) # Spatial data reading\rtlb_cities_gis %\u0026lt;\u0026gt;% fortify(region = \u0026quot;Codigo\u0026quot;) # %\u0026gt;% # Conv \u0026quot;spatial object\u0026quot; to data.frame\r# broom::tidy()\rplot_canarias \u0026lt;- F # Control param, initial app config\rif(plot_canarias==F){ # Should be moduled in a funct\rtlb_cities_gis %\u0026lt;\u0026gt;%\rfilter((long\u0026gt;0) \u0026amp; (lat\u0026gt;4000000)) # Filter peninsular data\r} \rPara terminar, joineamos los dos datasets creados para conformar el tablón final, el cual vamos a usar como base para crear las gráficas. Apuntar que usamos left join como forma de mantener los datos geos y no perder coordenadas en el plot.\ntbl_cities_avg_age \u0026lt;- tlb_cities_gis %\u0026gt;% left_join(tbl_census_2018, by = c(\u0026quot;id\u0026quot; = \u0026quot;postal_code\u0026quot;)) \rComo buena práctica, comprobamos el número de NAs generados a partir de este left join. Estos NAs serán municipios de los que tenemos coordenadas pero no contamos con información sobre la edad media.\nVemos que los valores perdidos representan únicamente el 1% del total de filas, por lo que vamos a imputarlos con el dato del código postal previo. Es cierto que podemos mejorar esta imputación, pero para nuestro propósito será suficiente debido al pequeño porcetaje del total que representan. ¡Vuelve a quedar de tu mano mejorarlo y comentárnoslo!\nkable( # RMarkdown output format\rtbl_cities_avg_age %\u0026gt;%\rgroup_by(id) %\u0026gt;%\rsummarise(na = sum(is.na(avg_age))) %\u0026gt;% # NAs by city\rsummarise(missing_perc = sum(na\u0026gt;0)/length(na)*100) %\u0026gt;% # Perc cities with at least 1 na select(missing_perc)\r,\ralign = \u0026quot;c\u0026quot;\r)\r\r\rmissing_perc\r\r\r\r0.9268413\r\r\r\rtbl_cities_avg_age %\u0026lt;\u0026gt;% arrange(id) %\u0026gt;% fill(avg_age, .direction = \u0026quot;down\u0026quot;) # Fill with the previous pc data.\r\n\r2.3- Visualización con Ggplot\rInspirado en gran medida en http://blog.manugarri.com/making-a-beautiful-map-of-spain-in-ggplot2/\nCon este dataset final, plotearemos las variables que representan las coordenadas en el eje X e Y y en primer lugar representaremos la edad media mediante la paleta de color. Las tonalidades rojas son asignadas a edades superiores y las azules a las edades medias más jóvenes. Conseguimos esto mediante el aesthetic fill de Ggplot.\nmyPalette \u0026lt;- colorRampPalette(rev(brewer.pal(11, \u0026quot;Spectral\u0026quot;))) # Create reverse Spectral palette\rplot_cities \u0026lt;- ggplot() +\rgeom_polygon(data = tbl_cities_avg_age, aes(fill = avg_age, x = long, y = lat, group = id)) + # Dummy variable to correct fill by PCode.\rscale_fill_gradientn(colours=myPalette(4)) + # Choose palette colours.\rlabs(fill=\u0026quot;Avg age\u0026quot;)\rplot(plot_cities)\r\n\r2.4- Visualización en 3D con Rayshader!\rEl anterior gráfico estaba bastante bien. En el podemos facilmente distinguir los municipios con la edad media más alta y los municipios más jóvenes. Sin embargo, los ojos humanos no son capaces de distinguir fácilmente entre colores próximos ni distinguir la magnitud de las diferencias en esta escala. Por lo tanto, ¿qué tal complementarlo con un nuevo eje?\nVeamos como hacerlo y que tal queda\nplot_gg(plot_cities,multicore=TRUE,width=5,height=3,scale=310) # Plot_gg de rayshader\rrender_snapshot()\r\nHmm dijiste algo sobre render_movie()… Qué tal si lo animamos?\n\n\r2.5- Animación 3D con Rayshader\rEn el gráfico anterior, la variable edad media queda bastante más entendible por el ojo humano en la dimensión añadida. Aquí la elección del ángulo e inclinación correctos es un punto esencial. Pero, ¿y mejoramos la interpretabilidad rotando el gráfico?\nEsto es de lo que se encarga la siguiente función:\nrender_movie(\u0026quot;img/movie_spain.mp4\u0026quot;,frames = 720, fps=30,zoom=0.6,fov = 30)\r\r\r","date":1564185600,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1569354975,"objectID":"84f08f930772bec1d6382accb7b1899f","permalink":"/es/posts/de-ggplot-a-3d-en-r-con-rayshader/","publishdate":"2019-07-27T00:00:00Z","relpermalink":"/es/posts/de-ggplot-a-3d-en-r-con-rayshader/","section":"posts","summary":"En 7 minutos, seremos capaces de convertir nuestras gráficas generadas con ggplot en espectaculares plots en 3D, ¡y ademas interactivos!\rPodrás embebernos en HTML/Rmarkdown, o incluso mejor, podras exportarlo como mp4 en una animacion rotatoria para sacarle todo el jugo a tus datos!\nComo caso de uso, vamos a visualizar la edad media de los municipios españoles cruzando datos del padrón con los datos GIS, para posteriormente visualizarlos en 3 dimensiones.","tags":["rayshader","ggplot","viz","vizR","visualization"],"title":"Convierte tu GGplot a una animación 3D. Genial 2D a 3D plots en R con Rayshader","type":"posts"}]