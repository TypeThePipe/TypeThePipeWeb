---
title: "Convierte tu GGplot en una animación 3D con R y Rayshader"
author: Carlos Vecina
date: '2019-07-27'
slug: "de-ggplot-a-3D-en-r-con-rayshader"
translationKey: "ggplot-to-3d-in-r-with-rayshader"
categories:
  - Post
  - R
tags:
  - rayshader
  - ggplot
  - viz
  - vizR
  - visualization
subtitle: ''
summary: ''
authors: [carlos-vecina]
lastmod: '2019-09-24T21:56:15+02:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []


---



<hr />
<p><em>En 7 minutos, seremos capaces de convertir nuestras gráficas generadas con ggplot en espectaculares plots en 3D, ¡y ademas interactivos!</em>
<em>Podrás embebernos en HTML/Rmarkdown, o incluso mejor, podras exportarlo como mp4 en una animacion rotatoria para sacarle todo el jugo a tus datos!</em></p>
<p><em>Como caso de uso, vamos a visualizar la edad media de los municipios españoles cruzando datos del padrón con los datos GIS, para posteriormente visualizarlos en 3 dimensiones.</em></p>
<hr />
<p><img src="/post/1c-ggplot-to-3d-in-r-with-rayshader/1c-ggplot-to-3d-in-r-with-rayshader_files/rayshader_header.png" /></p>
<p><br></p>
<div id="introducción" class="section level2">
<h2><strong>1. Introducción</strong></h2>
<p><br></p>
<p>En las últimas semanas, un ‘nuevo’ paquete de R ha centrado el interés de cierta parte de la comunidad. Decimos ‘nuevo’ porque se ha incorporado recientemente al CRAN, aunque realmente el primer commit realizado por su autor su repo de Github data de hace más de un año. Su nombre es <strong>rayshader</strong> y en palabras de su propio creador:</p>
<p><br></p>
<blockquote>
<p>“rayshader uses elevation data in a base R matrix and a combination of raytracing, spherical texture mapping, overlays, and ambient occlusion to generate beautiful topographic 2D and 3D maps”</p>
</blockquote>
<p><br></p>
<p>Bajo mi punto de vista, Tyler Morgan-Wall (el autor del paquete) dio con la tecla cuando incorporó al paquete dos nuevas funciones, plot_gg() y render_movie(). La primera de ellas nos permite convertir con 2 líneas de código nuestra visualización en ggplot a una figura 3D de una manera realmente facil y eficiente. La segunda de ellas renderiza esta figura y la anima, poniendo al alcance del usuario diversos parámetros para controlar el zoom, los fps, ángulo, inclinación…</p>
<p><br></p>
<p><img src="/post/1c-ggplot-to-3d-in-r-with-rayshader/1c-ggplot-to-3d-in-r-with-rayshader_files/rayshader_repo.png" /></p>
<p><br></p>
<div id="las-nuevas-funcionalidades-y-planteamiento-del-experimento" class="section level4">
<h4><strong>Las nuevas funcionalidades y planteamiento del experimento</strong></h4>
<p>La única condicion que debe cunplir tu gg-visualización es tener como <em>aesthetic</em> color o <em>fill</em>, y en algunos casos también puedes jugar con el <em>size</em></p>
<p>En demasiadas ocasiones, la visualización de datos en 3D no es la mejor opción a elegir, tal y como hablaremos un un futuro post. Por este motivo, he intentado traer un ejemplo donde el uso de la tercera dimensión aporte valor al análisis.</p>
<p>Este ejemplo práctico consistirá, como ya hemos avanzado, en la visualización en el mapa de España la edad media en cada municipio. ¿Chulo? Para ello necesitaremos:</p>
<ul>
<li><p>Los datos del censo sobre las estadísticas de la población (en este caso la edad media) por cada municipio. Estos datos los obtenemos de la web del INE.</p></li>
<li><p>Los datos GIS con las coordenadas de cada uno de los municipios que componen España.</p></li>
</ul>
<p>Una vez que tengamos estas dos fuentes de datos combinados, los visualizaremos y posteriormente exploraremos su renderización en un clip 3D con la figura rotando tal y como se ve en la imagen que encabeza este post.</p>
<p>¡Vayamos paso por paso!</p>
<p><br></p>
</div>
</div>
<div id="cdu-visualizando-la-edad-media-de-cada-municipio-en-españa" class="section level2">
<h2><strong>2. CdU: Visualizando la edad media de cada municipio en España</strong></h2>
<p>Una vez hemos establecido el objetivo principal y las diferentes fuentes de los datos, podemos proceder a la descarga y tratamiento de los mismos.</p>
<p><br></p>
<div id="descargando-los-datos-del-censo" class="section level3">
<h3>2.1- Descargando los datos del censo</h3>
<p>Como digimos, para llevar a cabo nuestro propósito, necesitamos acceder a dos fuentes diferentes de datos. Usaremos el portal de datos abiertos del INE para descargar la edad media en cada municipio español. Después de una búsqueda bastante ardua por su web, encontramos la información que buscábamos. Os dejo este link donde teneis acceso a lo que ellos llaman como estadísticas contínuas</p>
<p><a href="http://www.ine.es/dyngs/INEbase/es/operacion.htm?c=Estadistica_C&amp;cid=1254736177012&amp;menu=resultados&amp;secc=1254736195461&amp;idp=1254734710990">link</a>.</p>
<p>Con el objetivo de no irnos por las ramas, descargaremos directamente el fichero del 2018. Sin embargo, sí que es interesante citar la iniciativa <a href="https://github.com/oddworldng/INEbaseR/"><em>INEbase</em></a> de facilitar el acceso y la navegación en esta fuente de datos de INE.</p>
<p>Comenzamos cargando (o descargando) los paquetes necesarios para nuestro análisis. En un futuro post o tip compartiremos una función nuestra para la carga (o descarga en caso necesario) múltiple de paquetes en una sola linea.</p>
<pre class="r"><code>library(pxR)
library(RColorBrewer)
library(rgeos)
#install.packages(&quot;rgdal&quot;, repos = &quot;http://cran.us.r-project.org&quot;) reinstall cause gpclib dependencie https://stackoverflow.com/questions/30790036/error-istruegpclibpermitstatus-is-not-true
library(rgdal)
library(rayshader)
library(knitr)
library(magrittr)
library(tidyverse)

as.numeric.factor &lt;- function(x) {    # Custom function to convert fctr to num factor value
    return(suppressWarnings(as.numeric(levels(x))[x]))
}
 
if(!dir.exists(&quot;data&quot;)) dir.create(&quot;data&quot;)  # Create the download directory</code></pre>
<p><br></p>
<p>Descargando el fichero del INE 2018:</p>
<pre class="r"><code>utils::download.file(url = &quot;http://www.ine.es/pcaxisdl/t20/e245/p05/a2018/l0/00000006.px&quot;,
                     destfile = &quot;data/census_2018.px&quot;)</code></pre>
<p><br></p>
<pre class="r"><code>tbl_census_2018 &lt;- read.px(&quot;data/census_2018.px&quot;) %&gt;%              # Load &amp; format
  as_tibble()</code></pre>
<p>Parseamos los datos con el objetivo de conseguir un dataframe que consista en <em>name</em>, <em>postal_code</em>, <em>average_age</em></p>
<pre class="r"><code>tbl_census_2018 %&lt;&gt;% 
  set_names(c(&quot;age&quot;, &quot;city&quot;, &quot;sex&quot;, &quot;population&quot;)) %&gt;%             # Cambiamos los nombre
  na.omit() %&gt;%                                                    # Na rmv
  filter((city!=&quot;Total&quot;)&amp;(age!=&quot;Total&quot;)&amp;(sex==&quot;Ambos sexos&quot;)) %&gt;%  # Duplicate info rmv
  separate(city, c(&#39;postal_code&#39;, &#39;city_name&#39;), sep=&quot;-&quot;) %&gt;%       # Sep City column
  mutate(age = as.numeric.factor(age)) %&gt;%                         # Conv to numeric
  group_by(city_name, postal_code) %&gt;%                             # Group to operate
  summarise(avg_age = sum(population*age,na.rm = T)/sum(population,na.rm=T)) %&gt;%  # Avg age
  select(city_name, postal_code, avg_age)                          # Discard columns
kable(                                                             # Just Rmarkdown format
  tbl_census_2018 %&gt;% head(2)
  )</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">city_name</th>
<th align="left">postal_code</th>
<th align="right">avg_age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Ababuj</td>
<td align="left">44001</td>
<td align="right">52.40789</td>
</tr>
<tr class="even">
<td align="left">Abades</td>
<td align="left">40001</td>
<td align="right">45.40000</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="descargando-datos-gis" class="section level3">
<h3>2.2- Descargando datos GIS</h3>
<p>La segunda fuente de datos que vamos a utilizar son los datos geográficos de los municipios españoles, los cuales cruzaremos con los censales anteriormente descargados para pintar la edad media en sus respectivas coordenadas.</p>
<p>Descargando los daots GIS:</p>
<pre class="r"><code>temp &lt;- tempfile()                              # Create the tempfile
u=&quot;http://www.arcgis.com/sharing/rest/content/items/8e31c4c1a0b348f79058f212d0d807a1/data&quot;
utils::download.file(url = u, destfile = temp,
                     mode=&quot;wb&quot;)                 # Binary mode for correct download

unzip(temp, exdir = &quot;data/cities_gis&quot;)          # Unzip in data/cities_gis
unlink(temp)                                    # Delete temp file</code></pre>
<p>Tratamos estos datos para convertirlos de formato espacial a datos tabulares. Para este caso concreto de 3D, las Islas Canarias podrían deformarnos el gráfico, por lo que decidimos permanecer concentrados en nuestro objetivo didáctico y filtramos estas coordenadas. Por supuesto es posible mantenerlas sin perjudicar el gráfico, alterando sus coordenadas y acercándolas a la península. ¡Esto te queda como tarea para ti!</p>
<p>Para llevar a cabo este procesado de los datos, usamos la función <em>fortify</em> para no depender de más paquetes. No obstante esta funcion nos lanza un <em>warning</em> sugiriendonos el uso de la función <em>tidy()</em> del paquete <em>broom</em>.</p>
<pre class="r"><code>tlb_cities_gis &lt;- readOGR(dsn = &quot;data/cities_gis/Municipios_ETRS89_30N.shp&quot;,
                              verbose=FALSE) # Spatial data reading</code></pre>
<pre class="r"><code>tlb_cities_gis %&lt;&gt;% 
  fortify(region = &quot;Codigo&quot;) # %&gt;%             # Conv &quot;spatial object&quot; to data.frame
  # broom::tidy()

plot_canarias &lt;- F                              # Control param, initial app config

if(plot_canarias==F){                           # Should be moduled in a funct
  tlb_cities_gis %&lt;&gt;%
  filter((long&gt;0) &amp; (lat&gt;4000000))              # Filter peninsular data
} </code></pre>
<p>Para terminar, <em>joineamos</em> los dos datasets creados para conformar el tablón final, el cual vamos a usar como base para crear las gráficas. Apuntar que usamos <em>left join</em> como forma de mantener los datos geos y no perder coordenadas en el <em>plot</em>.</p>
<pre class="r"><code>tbl_cities_avg_age &lt;- tlb_cities_gis %&gt;% 
  left_join(tbl_census_2018, by = c(&quot;id&quot; = &quot;postal_code&quot;)) </code></pre>
<p>Como buena práctica, comprobamos el número de NAs generados a partir de este <em>left join</em>. Estos NAs serán municipios de los que tenemos coordenadas pero no contamos con información sobre la edad media.</p>
<p>Vemos que los valores perdidos representan únicamente el 1% del total de filas, por lo que vamos a imputarlos con el dato del código postal previo. Es cierto que podemos mejorar esta imputación, pero para nuestro propósito será suficiente debido al pequeño porcetaje del total que representan. ¡Vuelve a quedar de tu mano mejorarlo y comentárnoslo!</p>
<pre class="r"><code>kable(                                                      # RMarkdown output format
  tbl_cities_avg_age %&gt;%
    group_by(id) %&gt;%
    summarise(na = sum(is.na(avg_age))) %&gt;%                 # NAs by city
    summarise(missing_perc = sum(na&gt;0)/length(na)*100) %&gt;%  # Perc cities with at least 1 na 
    select(missing_perc)
  ,
  align = &quot;c&quot;
  )</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">missing_perc</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0.9268413</td>
</tr>
</tbody>
</table>
<pre class="r"><code>tbl_cities_avg_age %&lt;&gt;%       
  arrange(id) %&gt;% 
  fill(avg_age, .direction = &quot;down&quot;)            # Fill with the previous pc data.</code></pre>
<p><br></p>
</div>
<div id="visualización-con-ggplot" class="section level3">
<h3>2.3- Visualización con Ggplot</h3>
<p>Inspirado en gran medida en <a href="http://blog.manugarri.com/making-a-beautiful-map-of-spain-in-ggplot2/" class="uri">http://blog.manugarri.com/making-a-beautiful-map-of-spain-in-ggplot2/</a></p>
<p>Con este dataset final, plotearemos las variables que representan las coordenadas en el eje X e Y y en primer lugar representaremos la edad media mediante la paleta de color. Las tonalidades rojas son asignadas a edades superiores y las azules a las edades medias más jóvenes. Conseguimos esto mediante el <em>aesthetic fill</em> de Ggplot.</p>
<pre class="r"><code>myPalette &lt;- colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))      # Create reverse Spectral palette

plot_cities &lt;- ggplot() +
  geom_polygon(data = tbl_cities_avg_age, aes(fill = avg_age,   
                                         x = long, 
                                         y = lat, 
                                         group = id)) +      # Dummy variable to correct fill by PCode.
  scale_fill_gradientn(colours=myPalette(4)) +                 # Choose palette colours.
  labs(fill=&quot;Avg age&quot;)
plot(plot_cities)</code></pre>
<p><img src="/es/post/de-ggplot-a-3d-en-r-con-rayshader/index_files/figure-html/unnamed-chunk-13-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><br></p>
</div>
<div id="visualización-en-3d-con-rayshader" class="section level3">
<h3>2.4- Visualización en 3D con Rayshader!</h3>
<p>El anterior gráfico estaba bastante bien. En el podemos facilmente distinguir los municipios con la edad media más alta y los municipios más jóvenes. Sin embargo, los ojos humanos no son capaces de distinguir fácilmente entre colores próximos ni distinguir la magnitud de las diferencias en esta escala. Por lo tanto, ¿qué tal complementarlo con un nuevo eje?</p>
<p>Veamos como hacerlo y que tal queda</p>
<pre class="r"><code>plot_gg(plot_cities,multicore=TRUE,width=5,height=3,scale=310)    # Plot_gg de rayshader
render_snapshot()</code></pre>
<p><img src="/es/post/de-ggplot-a-3d-en-r-con-rayshader/index_files/figure-html/unnamed-chunk-14-1.png" width="200%" height="200%" style="display: block; margin: auto;" /></p>
<p><br></p>
<p>Hmm dijiste algo sobre render_movie()… Qué tal si lo animamos?</p>
<p><br></p>
</div>
<div id="animación-3d-con-rayshader" class="section level3">
<h3>2.5- Animación 3D con Rayshader</h3>
<p>En el gráfico anterior, la variable edad media queda bastante más entendible por el ojo humano en la dimensión añadida. Aquí la elección del ángulo e inclinación correctos es un punto esencial. Pero, ¿y mejoramos la interpretabilidad rotando el gráfico?</p>
<p>Esto es de lo que se encarga la siguiente función:</p>
<pre class="r"><code>render_movie(&quot;img/movie_spain.mp4&quot;,frames = 720, fps=30,zoom=0.6,fov = 30)</code></pre>
<p><img src="/post/1c-ggplot-to-3d-in-r-with-rayshader/1c-ggplot-to-3d-in-r-with-rayshader_files/movie_spain.gif" /></p>
<style>
body {
text-align: justify}
p {
  word-spacing: 3px;
}
</style>
</div>
</div>
