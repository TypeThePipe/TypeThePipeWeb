---
title: Pydantic parse objects with parse_obj and parse_obj_as methods
author: Carlos Vecina Tebar
date: '2023-10-23'
slug: pydantic-parse-obj
translationKey: pydantic-parse-obj
output: 
  blogdown::html_page:
    highlight: pygments 
categories:
  - Python
  - Post
tags: [Python, Pydantic]
subtitle: "Effortless Data Parsing: Deep dive into Pydantic's parse_obj and parse_obj_as methods."
summary: "Effortless Data Parsing: Deep dive into Pydantic's parse_obj and parse_obj_as methods."
authors: [carlos-vecina]
featured: false
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<p><img src="featured.png" width="400px" alt="Pydantic Python library logo." /></p>
<div id="converting-objects-and-files-into-pydantic-models-all-you-need-to-know" class="section level1">
<h1>Converting objects and files into Pydantic models? All you need to know</h1>
<p>Converting objects and files into Pydantic models might sound like a magical transformation, and in a way, it is! In this enchanting journey of data manipulation, we‚Äôre going to unveil all the secrets you need to know. Pydantic, with its data validation superpowers, not only helps you create well-structured models but also allows you to effortlessly breathe life into them from various sources.</p>
<p>Imagine turning a plain, old Python dictionary or even a JSON file into a fully-fledged Pydantic model with just a few lines of code. It‚Äôs like casting a spell! Whether you‚Äôre dealing with API responses, database records, or just want to make sense of your data, Pydantic has your back. So, prepare to unlock the magic of converting objects and files into Pydantic models, and let‚Äôs embark on this captivating adventure together! ‚ú®</p>
<p><br></p>
<div id="how-to-load-a-pydantic-model-from-an-object.-pydantic-parse_obj-example" class="section level2">
<h2><strong>How to load a Pydantic model from an object. Pydantic parse_obj example</strong></h2>
<p>Hey there, Pydantic enthusiasts! If you‚Äôve ever delved into the world of Pydantic, you know it‚Äôs a superhero in the realm of data validation and parsing in Python. But what‚Äôs the deal with loading a Pydantic model from an object, you ask? Well, it‚Äôs an exciting adventure, and in this Pydantic parse_obj example, we‚Äôre about to embark on a thrilling journey together! üöÄ</p>
<p>Picture this: you‚Äôre dealing with API requests, taming wild database records, or just trying to wrangle some unruly data. That‚Äôs where Pydantic‚Äôs parse_obj swoops in like a caped crusader, making data validation and transformation a total breeze. So, fasten your seatbelts, and let‚Äôs learn how to wield this incredible power and turn your Python data-handling tasks into a supercharged, fun-filled experience!‚Äù</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">from</span> pydantic <span class="im">import</span> BaseModel, Field, parse_obj_as</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Literal, Optional, Annotated, Union</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">from</span> datetime <span class="im">import</span> date</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="kw">class</span> ComputerScienceApplicant(BaseModel):</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>    <span class="kw">class</span> Config:</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>        orm_mode <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>    degree: Literal[<span class="st">&quot;ComputerScience&quot;</span>]</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>    birth_date: date <span class="op">|</span> <span class="va">None</span> <span class="co"># preferred now vs Optional[]</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>    </span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="kw">class</span> BiologyApplicant(BaseModel):</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>    degree: Literal[<span class="st">&quot;Biology&quot;</span>]</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>    birth_date: date <span class="op">|</span> <span class="va">None</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>    </span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a>applicant_dict <span class="op">=</span> {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;Diana&quot;</span>, <span class="st">&quot;degree&quot;</span>: <span class="st">&quot;ComputerScience&quot;</span>, <span class="st">&quot;birth_date&quot;</span>: date(<span class="dv">2022</span>,<span class="dv">1</span>,<span class="dv">1</span>)}</span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a>ComputerScienceApplicant(<span class="op">**</span>applicant_dict)</span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a>ComputerScienceApplicant.parse_obj(applicant_dict)</span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a>ComputerScienceApplicant.from_orm(ComputerScienceApplicant(<span class="op">**</span>applicant_dict))</span></code></pre></div>
<p>Pydantic parse_obj method is preferred over the dict unpacking way.</p>
</div>
<div id="the-correct-usage-of-parse_obj_as-and-parse_file_as." class="section level2">
<h2><strong>The correct usage of parse_obj_as and parse_file_as.</strong></h2>
<p>From converting between BaseModels to parse_obj into discriminated union.</p>
<p>Pydantic offers a nifty standalone utility function known as parse_obj_as that‚Äôs like a versatile tool in your Python utility belt. It enables you to apply Pydantic‚Äôs parsing wizardry in a more flexible and on-the-fly manner, allowing you to work with a broader range of Pydantic-compatible types.</p>
<p>Why is this so cool, you could ask? Well, think of it like this: you‚Äôre in a situation where you need to parse results into a type that doesn‚Äôt directly inherit from BaseModel. This function is handy also to parse and object into a Pydantic discriminated union without creating another class. For example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>Applicant <span class="op">=</span> Annotated[Union[ComputerScienceApplicant, BiologyApplicant], Field(discriminator<span class="op">=</span><span class="st">&quot;degree&quot;</span>)]</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co">#Applicant.parse_obj({&quot;isPrimary&quot;: True, &quot;dateOfBirth&quot;: date(2022,1,1)})</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>parse_obj_as(Applicant, {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;Paul&quot;</span>, <span class="st">&quot;degree&quot;</span>: <span class="st">&quot;Biology&quot;</span>, <span class="st">&quot;birth_date&quot;</span>: date(<span class="dv">2012</span>,<span class="dv">1</span>,<span class="dv">1</span>)})</span></code></pre></div>
<p>You can explore more about <a href="https://typethepipe.com/post/pydantic-discriminated-union/">Annotated union discriminator</a> post.</p>
<div id="load-pydantic-model-from-file-with-parse_file_as" class="section level3">
<h3>Load Pydantic model from file with parse_file_as</h3>
<p>Pydantic offers us an extra layer for load a file into a Pydantic model directly. This feature can be especially handy when you need to work with structured data stored in files such as JSON or other formats. Here there is a simple example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>parse_file_as(path<span class="op">=</span><span class="st">&quot;applicants.json&quot;</span>, type_<span class="op">=</span>Applicant)</span></code></pre></div>
<p>That under-the-hood, it is a few code lines / time-saving tool that is calling to load_file, and then parse_obj_as as the previous example.</p>
<p><br></p>
</div>
<div id="how-to-parse-a-list-of-objects-to-a-list-of-pydantic-basemodels" class="section level3">
<h3>How to parse a list of objects to a list of Pydantic BaseModels?</h3>
<p>OK, so we already get how to convert raw objects into Pydantic models. If you have any doubt, feel free to contact us.</p>
<p>So what about nested Pydantic models? For example, following the previous example, we need a list of Applicants.</p>
<ul>
<li>In Pydantic V1:
This is now possible using the already commented parse_obj_as. We could use now the base type <code>list</code> and do it without the need of an specific object.</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>users <span class="op">=</span> [</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>    {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;Paul&quot;</span>, <span class="st">&quot;degree&quot;</span>: <span class="st">&quot;ComputerScience&quot;</span>, <span class="st">&quot;birth_date&quot;</span>: date(<span class="dv">2012</span>,<span class="dv">1</span>,<span class="dv">1</span>)}, </span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>    {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;Celia&quot;</span>, <span class="st">&quot;degree&quot;</span>: <span class="st">&quot;Biology&quot;</span>, <span class="st">&quot;birth_date&quot;</span>: date(<span class="dv">1994</span>,<span class="dv">5</span>,<span class="dv">12</span>)}</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>]</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>parse_obj_as(<span class="bu">list</span>[Applicant], users)</span></code></pre></div>
<p>An alternative way to do that, if you want to create a new object representative of this list, them:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="kw">class</span> ApplicantList(BaseModel):</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>    __root__: <span class="bu">list</span>[Applicant]</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    </span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>ApplicantList.parse_obj(users)</span></code></pre></div>
<p>Note that if you convert it to <code>.dict()</code> the root key is conserved, but if you do it with <code>.json()</code> method, the <code>__root__</code> key will disappear. You also have the option to overwrite the dict method as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">class</span> ApplicantList(BaseModel):</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>    __root__: <span class="bu">list</span>[Applicant]</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>    </span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">dict</span>(<span class="va">self</span>):</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">super</span>().<span class="bu">dict</span>()[<span class="st">&#39;__root__&#39;</span>]</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>    </span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>ApplicantList.parse_obj(users).<span class="bu">dict</span>()</span></code></pre></div>
<ul>
<li>In Pydantic V2:
Use <a href="https://typethepipe.com/post/pydantic-discriminated-union/">Type Adapter</a> as we state in that post, in order to do:</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="im">from</span> pydantic <span class="im">import</span> TypeAdapter</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>users <span class="op">=</span> [</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>    {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;Paul&quot;</span>, <span class="st">&quot;degree&quot;</span>: <span class="st">&quot;ComputerScience&quot;</span>, <span class="st">&quot;birth_date&quot;</span>: date(<span class="dv">2012</span>,<span class="dv">1</span>,<span class="dv">1</span>)}, </span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>    {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;Celia&quot;</span>, <span class="st">&quot;degree&quot;</span>: <span class="st">&quot;Biology&quot;</span>, <span class="st">&quot;birth_date&quot;</span>: date(<span class="dv">1994</span>,<span class="dv">5</span>,<span class="dv">12</span>)}</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>]</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>ta <span class="op">=</span> TypeAdapter(List[User])</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>m <span class="op">=</span> ta.validate_python(users)</span></code></pre></div>
</div>
<div id="pydantic-list-of-different-types" class="section level3">
<h3>Pydantic list of different types</h3>
<p>When you need to work with a list containing different types of data, Pydantic offers a straightforward solution. Here‚Äôs how you can define a Pydantic model for a list that accommodates different data types:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="kw">class</span> ApplicantList(BaseModel):</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>    __root__: <span class="bu">list</span>[ComputerScienceApplicant <span class="op">|</span> BiologyApplicant]</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    </span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>ApplicantList.parse_obj(users)</span></code></pre></div>
<p><br></p>
</div>
<div id="convert-between-pydantic-basemodels" class="section level3">
<h3>Convert between Pydantic BaseModels</h3>
<p>Also it could be convinient to mutate and convert between different BaseModels. Whether you‚Äôre migrating from one data model to another, integrating data from various sources, or even orchestrating a complex data transformation dance, Pydantic simplifies the process. With just a few lines of code, you can mutate, merge, and seamlessly convert between different BaseModels.</p>
<p>In this exmple we are converting from a regular BaseModel to another, without existing inheritance between them.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="im">from</span> pydantic <span class="im">import</span> BaseModel, parse_obj_as</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="im">from</span> enum <span class="im">import</span> Enum</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="kw">class</span> PetTypeEnum(Enum):</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>    DOG <span class="op">=</span> <span class="st">&quot;dog&quot;</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>    CAT <span class="op">=</span> <span class="st">&quot;cat&quot;</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>    BIRD <span class="op">=</span> <span class="st">&quot;bird&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="kw">class</span> Pet(BaseModel):</span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>  name: <span class="bu">str</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>  pet_type: PetTypeEnum</span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="kw">class</span> TypelessPet(BaseModel):</span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a>  name: <span class="bu">str</span></span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a>meww <span class="op">=</span> Pet(name<span class="op">=</span><span class="st">&quot;Meww&quot;</span>, pet_type<span class="op">=</span><span class="st">&quot;cat&quot;</span>)</span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a>typeless_meww <span class="op">=</span> parse_obj_as(TypelessPet, meww)</span>
<span id="cb9-18"><a href="#cb9-18" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" tabindex="-1"></a><span class="cf">assert</span> meww.pet_type.value <span class="op">==</span> <span class="st">&quot;cat&quot;</span></span>
<span id="cb9-20"><a href="#cb9-20" tabindex="-1"></a><span class="cf">assert</span> typeless_meww.name <span class="op">==</span> meww.name</span>
<span id="cb9-21"><a href="#cb9-21" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> <span class="bu">hasattr</span>(typeless_meww, <span class="st">&quot;pet_type&quot;</span>)</span></code></pre></div>
<p><br>¬¥</p>
</div>
</div>
<div id="stay-updated-on-pydantic-and-python-tips" class="section level2">
<h2><strong>Stay updated on Pydantic and Python tips</strong></h2>
<p>Hopefully, this post has helped familiarize you with the usage of unions and discriminators in Pydantic, showcasing some of its functionalities and enabling you to enjoy their benefits.</p>
<p>If you want to stay updated‚Ä¶</p>
<!-- Begin Mailchimp Signup Form -->
<link href="//cdn-images.mailchimp.com/embedcode/horizontal-slim-10_7.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="https://csshake.surge.sh/csshake.min.css">
<style type="text/css">
	#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; width:100%;}
	 #mc_embed_signup .button {
  background-color: #0294A5; /* Green */
  color: white;
  transition-duration: 0.4s;
}
#mc_embed_signup .button:hover {
  background-color: #379392 !important; 
}

</style>
<div id="mc_embed_signup">
<form action="https://typethepipe.us4.list-manage.com/subscribe/post?u=91551f7ed29389a0de4f47665&amp;id=d95c503a48" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
 <div id="mc_embed_signup_scroll">
	<label for="mce-EMAIL"> Suscribe for more Python and Pydantic tips!</label>
	<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="your best email" required>
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_91551f7ed29389a0de4f47665_d95c503a48" tabindex="-1" value=""></div>
    <div class="clear"><input type="submit" value="Submit!" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<style>
p {
  word-spacing: 3px;
  text-indent: 20px;
  text-align: justify;
}
.page-subtitle {
  text-align: left  !important;
    text-indent: 0px !important;
}
.card-text {
  text-align: left  !important;
    text-indent: 0px !important;
}
</style>
<style>
.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#2e8516;font-weight:bold}.hljs-comment, .hljs-quote {
    color: #0e847b;
    font-style: italic;
}.hljs-number, .hljs-literal, .hljs-variable, .hljs-template-variable, .hljs-tag .hljs-attr {
    color: #008021;
}
</style>
</div>
</div>
